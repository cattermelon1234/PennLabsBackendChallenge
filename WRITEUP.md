# Open-Ended Questions

## 1.

I started working on the login/authentication system, but unfortunately, I wasn’t able to completely finish. However, I did make changes in my model.py and app.py files of a partial implementation, which are currently commented out. I used the python package flask_bcrypt to hash(encode) the user passwords and validate if the given password matches with the real password. If I were to store raw user passwords in my database, that could lead to potentially harmful security breaches, which would put users’ key personal information at risk. Thus, the hashing and validation is a way to verify a user’s identity while maintaining security.
I created three routes for authentication: /login, /register, /logout. “/login” validates if your password matches with the username in the database and logs the user in, “/register” creates a new instance of User in the database with a username and encoded password, and “/logout” automatically logs a user out.
I would use JWT tokens to implement sessions for users logins. When a user is logging in or registering, the server can send an encoded private jwt token to the user, which can encode their username, id, and their session expiry date. After that, for specific requests like modifying clubs or adding clubs, I would require token authentication: users would have to use jwt.io to verify their signature by inputting the encoded jwt and the server’s secret key, and can pass in their new token as an argument to their requests.
I would also make a decorator function, token_auth in app.py, which checks if a valid token or any token at all is passed as a parameter to a request. If not, errors will be returned. Again, I would apply this function to specific requests like modifying or adding clubs.

## 2.

I would begin by creating a “Comment” database, which would contain the columns: “id”, “poster_username”, “content”, “parent_post”, “parent_comment”, and “child_comments”. Each comment must have a parent post that it is commented under, so I would create a many to one database relationship between a comment and a parent post (since posts can have multiple comments, but not the other way around).
The more difficult part would be the parent_comment and child_comments columns. I would use an association or secondary table for this, since parent comments can have multiple child comments.
The association table would have two columns: “parent_comment_id” and “child_comment_id”. If a comment with say, id 100, is a child of comment id 200, we would have a row in the assoc table containing 200 as the parent comment id and 100 as the child comment id. This way, we can store every single parent-child relationship, and even child comments can be parents.
To create a new comment, we can instantiate a comment with some of the fields. To add a comment as a child to another comment, we can first instantiate a new comment with the original comment as its “parent_comment”, and then append it to the child_comments relationship column in the parent comment. We could also use back_populates to populate our table and databases automatically every time a new child comment is added.
To delete comments, we would have to iterate through all of its children's comments, then continue iterating through their children, and so on. We could define a recursive function to continue down the line until we reach the “deepest” child comments, and delete them one by one until we reach back to the top and delete the original comment. Deleting a post should utilize the same function to delete all of its comments.

## 3.

I implemented route caching in my code through the flask_caching python package. I implemented a 30 second cache timeout for the “/clubs” route, which gets a list of all clubs and their attributes, the “/search” route, which searches for a club by name and returns its info, and the “/<user_id>” route, which searches for a user and returns their info. I chose these routes because, at least from my understanding, there really isn’t much of a point route_caching for post functions.
The use of caching is to save memory and computing power while appeasing the user. This would make sense for GET requests, because we don’t need to constantly query the database when the information will likely stay the same for a good period of time. For POST requests, the database is being changed, so there isn’t really a purpose to caching.
As for cache invalidation, I didn’t implement this because I wasn’t sure how to test it. I tested my normal caching through POSTMAN by running a simple get request for the list of clubs, then changed the name of a club through post, and then reran the get request to check if the list was the same. However, it would be difficult to test after implementing cache invalidation, since my “test” is essentially exploiting the main issue with caching, which would now be fixed through cache invalidation.
Nevertheless, I could use the function “cache.delete_memoized(<function_name>)” to perform cache invalidation on a function-by-function basis. For example, at the end of every POST request to modify or add a club, I could run cache.delete_memoized(<getClubs()>), which would make sure the user never gets faulty or out-of-date cache data.
